#!/usr/bin/env bats
load temp/test-helpers

setup() {
  source ${BATS_TEST_DIRNAME}/steps.sh
  export mock_needs="$(mock_bin needs)"
  export mock_mrlog="$(mock_bin mrlog)"
  export mock_helm="$(mock_bin helm)"
  export mock_kubectl="$(mock_bin kubectl)"
  export PATH="${BIN_MOCKS}:${PATH}"
}

teardown() {
  clean_bin_mocks
}

@test "logs existing dependencies if it exists" {
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  DEPENDENCIES_FILE="${BATS_TMPDIR}/dependencies.log"
  echo "content of dependencies.log" > "${DEPENDENCIES_FILE}"

  run log_existing_dependencies

  [ "$(mock_get_call_num "${mock_mrlog}")" = "2" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 1)" = "section-start --name log existing dependencies" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 2)" = "section-end --name log existing dependencies --result=0" ]

  status_equals 0
  output_says "section-start"
  output_says "content of dependencies.log"
  output_says "section-end"
}

@test "fails if dependencies not generated by the developer" {
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  DEPENDENCIES_FILE="${BATS_TMPDIR}/dependencies.log"
  rm -f "${DEPENDENCIES_FILE}"

  run log_existing_dependencies

  [ "$(mock_get_call_num "${mock_mrlog}")" = "2" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 1)" = "section-start --name log existing dependencies" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 2)" = "section-end --name log existing dependencies --result=0" ]

  status_equals 1
  output_says "section-start"
  output_says "section-end"

}


@test "When requirements are not met" {
  mock_set_status "${mock_needs}" 1
  mock_set_side_effect "${mock_needs}" "echo needs" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run requirements_check

  [ "$(mock_get_call_num "${mock_needs}")" = "1" ]
  [ "$(mock_get_call_args "${mock_needs}" 1)" = "check" ]

  [ "$(mock_get_call_num "${mock_mrlog}")" = "2" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 1)" = "section-start --name requirements check" ]
  [ "$(mock_get_call_args "${mock_mrlog}" 2)" = "section-end --name requirements check --result=1" ]

  status_equals 1
  output_says "section-start"
  output_says "needs"
  output_says "The requirements in needs.json were not completely met"
  output_says "section-end"
}


@test "When requirements are met" {
  mock_set_status "${mock_needs}" 0
  mock_set_side_effect "${mock_needs}" "echo needs" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run requirements_check

  [ "$(mock_get_call_num "${mock_needs}")" = "1" ]
  [ "$(mock_get_call_args "${mock_needs}" 1)" = "check" ]
  output_says "section-start"
  output_says "needs"
  output_says "The requirements in needs.json were met"
  output_says "section-end"
  status_equals 0
}

@test "Successful helm init" {
  mock_set_side_effect "${mock_helm}" "echo helm"
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run init_helm

  [ "$(mock_get_call_num "${mock_helm}")" = "1" ]
  [ "$(mock_get_call_args "${mock_helm}" 1)" = "init" ]
  output_says "section-start"
  output_says "helm"
  output_says "Helm initialized!"
  output_says "section-end"
  status_equals 0
}

@test "Failed helm init" {
  mock_set_status "${mock_helm}" 1
  mock_set_side_effect "${mock_helm}" "echo helm"
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run init_helm

  [ "$(mock_get_call_num "${mock_helm}")" = "1" ]
  [ "$(mock_get_call_args "${mock_helm}" 1)" = "init" ]
  output_says "section-start"
  output_says "helm"
  output_says "Failed to initialize helm."
  output_says "section-end"
  status_equals 1
}

@test "Successful helm removal" {
  mock_set_side_effect "${mock_kubectl}" "echo pkstcl"
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run remove_helm

  [ "$(mock_get_call_num "${mock_kubectl}")" = "1" ]
  [ "$(mock_get_call_args "${mock_kubectl}" 1)" = "delete deployment tiller-deploy -n kube-system" ]
  output_says "section-start"
  output_says "pkstcl"
  output_says "Helm removed!"
  output_says "section-end"
  status_equals 0
}

@test "Failed helm removal" {
  mock_set_side_effect "${mock_kubectl}" "echo pkstcl"
  mock_set_status "${mock_kubectl}" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-start" 1
  mock_set_side_effect "${mock_mrlog}" "echo section-end" 2

  run remove_helm

  [ "$(mock_get_call_num "${mock_kubectl}")" = "1" ]
  [ "$(mock_get_call_args "${mock_kubectl}" 1)" = "delete deployment tiller-deploy -n kube-system" ]
  output_says "section-start"
  output_says "pkstcl"
  output_says "Failed to remove helm."
  output_says "section-end"
  status_equals 1
}